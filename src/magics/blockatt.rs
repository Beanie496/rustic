/**
 * blockatt.rs is the Blockers/Attacks generation module.
 * It generates all possible blocker boards for a given mask,
 * rook attack boards, and bishop attack boards.
*/
use super::{AttackBoards, BlockerBoards, EMPTY, MAX_PERMUTATIONS};
use crate::defines::Bitboard;
use crate::utils::{create_bb_ray, Direction};

/**
 * create_blocker_boards() takes a mask. This is a bitboard in which
 * all the bits are set for a square a slider can move to, without the
 * edges. (As generated by the functions in the mask.rs module.)
 * create_blocker_boards() generates all possible permutations for the
 * given mask, using the Carry Rippler method. See the given link, or
 * http://rustic-chess.org for more information.
*/
pub fn create_blocker_boards(mask: Bitboard) -> BlockerBoards {
    let d: Bitboard = mask;
    let mut bb_blocker_boards: BlockerBoards = [EMPTY; MAX_PERMUTATIONS];
    let mut n: Bitboard = 0;
    let mut i = 0;

    // Carry-Rippler
    // https://www.chessprogramming.org/Traversing_Subsets_of_a_Set
    loop {
        bb_blocker_boards[i] = n;
        n = n.wrapping_sub(d) & d;
        i += 1;
        if n == 0 {
            break;
        }
    }

    bb_blocker_boards
}

/**
 * This function takes a square, and all the blocker boards belonging to that squre.
 * Then it'll iterate through those blocker boards, and generate the attack board
 * belonging to that blocker board. The 'length' parameter is the length of the given
 * array of blocker boards.
*/
pub fn create_rook_attack_boards(sq: u8, blockers: BlockerBoards, length: u64) -> AttackBoards {
    let mut bb_attack_boards: AttackBoards = [EMPTY; MAX_PERMUTATIONS];

    for i in 0..length {
        let index = i as usize;
        let bb_attacks = create_bb_ray(blockers[index], sq, Direction::Up)
            | create_bb_ray(blockers[index], sq, Direction::Right)
            | create_bb_ray(blockers[index], sq, Direction::Down)
            | create_bb_ray(blockers[index], sq, Direction::Left);
        bb_attack_boards[index] = bb_attacks;
    }

    bb_attack_boards
}

/* Same as the function above, but for the bishop. */
pub fn create_bishop_attack_boards(sq: u8, blockers: BlockerBoards, length: u64) -> AttackBoards {
    let mut bb_attack_boards: AttackBoards = [EMPTY; MAX_PERMUTATIONS];

    for i in 0..length {
        let index = i as usize;
        let bb_attacks = create_bb_ray(blockers[index], sq, Direction::UpLeft)
            | create_bb_ray(blockers[index], sq, Direction::UpRight)
            | create_bb_ray(blockers[index], sq, Direction::DownRight)
            | create_bb_ray(blockers[index], sq, Direction::DownLeft);
        bb_attack_boards[index] = bb_attacks;
    }

    bb_attack_boards
}
